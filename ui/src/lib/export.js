import { getState } from './state.js';

export function exportSWML() {
  const state = getState();
  const swml = buildSWMLFromState(state);

  const blob = new Blob([JSON.stringify(swml, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${state.agent.name.replace(/\s+/g, '_').toLowerCase()}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

export function exportPythonSDK() {
  const state = getState();
  const code = buildPythonSDKCode(state);

  const blob = new Blob([code], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${state.agent.name.replace(/\s+/g, '_').toLowerCase()}.py`;
  a.click();
  URL.revokeObjectURL(url);
}

function buildSWMLFromState(state) {
  const swml = {
    version: '1.0.0',
    sections: {
      main: [
        { answer: {} }
      ]
    }
  };

  // Build AI configuration
  const aiConfig = {
    prompt: {
      pom: state.basePrompt
    }
  };

  // Build contexts
  if (Object.keys(state.contexts).length > 0) {
    aiConfig.prompt.contexts = {};

    Object.values(state.contexts).forEach(context => {
      const contextData = {
        steps: []
      };

      // Add context prompt if exists
      if (context.prompt && context.prompt.length > 0) {
        contextData.prompt = {
          pom: context.prompt
        };
      }

      // Add steps
      Object.values(context.steps).forEach(step => {
        const stepData = {
          name: step.name
        };

        // Add instructions as text (POM sections concatenated)
        if (step.instructions && step.instructions.length > 0) {
          stepData.text = step.instructions.map(section => {
            let text = `## ${section.title}\n`;
            if (section.bullets) {
              text += section.bullets.map(b => `- ${b}`).join('\n');
            } else if (section.body) {
              text += section.body;
            }
            return text;
          }).join('\n\n');
        }

        if (step.criteria) {
          stepData.step_criteria = step.criteria;
        }

        if (step.functions && step.functions.length > 0) {
          if (step.functions.includes('none')) {
            stepData.functions = 'none';
          } else {
            stepData.functions = step.functions.map(funcId => {
              const func = state.functions[funcId];
              return func ? func.name : funcId;
            });
          }
        }

        if (step.validSteps && step.validSteps.length > 0) {
          stepData.valid_steps = step.validSteps.map(stepId => {
            // Find step name
            for (const ctx of Object.values(state.contexts)) {
              if (ctx.steps[stepId]) {
                return ctx.steps[stepId].name;
              }
            }
            return stepId;
          });
        }

        if (step.validContexts && step.validContexts.length > 0) {
          stepData.valid_contexts = step.validContexts.map(ctxId => {
            const ctx = state.contexts[ctxId];
            return ctx ? ctx.name : ctxId;
          });
        }

        contextData.steps.push(stepData);
      });

      aiConfig.prompt.contexts[context.name] = contextData;
    });
  }

  // Add functions
  if (Object.keys(state.functions).length > 0) {
    aiConfig.functions = Object.values(state.functions).map(func => {
      const funcData = {
        function: func.name,
        purpose: func.purpose || 'Custom function'
      };

      if (func.parameters && func.parameters.length > 0) {
        funcData.argument = {};
        func.parameters.forEach(param => {
          funcData.argument[param.name] = {
            type: param.type,
            description: param.description || ''
          };
          if (param.required) {
            if (!funcData.argument_required) {
              funcData.argument_required = [];
            }
            funcData.argument_required.push(param.name);
          }
        });
      }

      if (func.webHookUrl) {
        funcData.web_hook_url = func.webHookUrl;
      }

      return funcData;
    });
  }

  // Add AI config
  if (state.aiConfig.temperature !== undefined) {
    aiConfig.temperature = state.aiConfig.temperature;
  }
  if (state.aiConfig.top_p !== undefined) {
    aiConfig.top_p = state.aiConfig.top_p;
  }

  swml.sections.main.push({ ai: aiConfig });

  return swml;
}

function buildPythonSDKCode(state) {
  const className = state.agent.name.replace(/\s+/g, '') + 'Agent';

  let code = `#!/usr/bin/env python3
"""
${state.agent.name}
Auto-generated by SignalWire Agent Builder
"""

from signalwire_agents import AgentBase


class ${className}(AgentBase):
    def __init__(self):
        super().__init__(
            name="${state.agent.name}",
            route="${state.agent.route}"
        )

`;

  // Base prompt
  if (state.basePrompt && state.basePrompt.length > 0) {
    state.basePrompt.forEach(section => {
      if (section.bullets) {
        code += `        self.prompt_add_bullets("${section.title}", [\n`;
        section.bullets.forEach(bullet => {
          code += `            "${bullet}",\n`;
        });
        code += `        ])\n`;
      } else {
        code += `        self.prompt_add_section("${section.title}", "${section.body || ''}")\n`;
      }
    });
    code += '\n';
  }

  // Contexts and steps
  if (Object.keys(state.contexts).length > 0) {
    code += `        # Define contexts\n`;
    code += `        contexts = self.define_contexts()\n\n`;

    Object.values(state.contexts).forEach(context => {
      code += `        # Context: ${context.name}\n`;
      code += `        ${context.name}_context = contexts.add_context("${context.name}")\n`;

      if (context.isolated) {
        code += `        ${context.name}_context.set_isolated(True)\n`;
      }

      // Context prompt
      if (context.prompt && context.prompt.length > 0) {
        context.prompt.forEach(section => {
          if (section.bullets) {
            code += `        ${context.name}_context.add_bullets("${section.title}", [\n`;
            section.bullets.forEach(bullet => {
              code += `            "${bullet}",\n`;
            });
            code += `        ])\n`;
          } else {
            code += `        ${context.name}_context.add_section("${section.title}", "${section.body || ''}")\n`;
          }
        });
      }

      // Steps
      Object.values(context.steps).forEach(step => {
        code += `\n        ${context.name}_context.add_step("${step.name}") \\\n`;

        if (step.instructions && step.instructions.length > 0) {
          step.instructions.forEach(section => {
            code += `            .add_section("${section.title}", "${section.body || ''}") \\\n`;
          });
        }

        if (step.criteria) {
          code += `            .set_step_criteria("${step.criteria}") \\\n`;
        }

        if (step.validSteps && step.validSteps.length > 0) {
          const stepNames = step.validSteps.map(stepId => {
            for (const ctx of Object.values(state.contexts)) {
              if (ctx.steps[stepId]) {
                return `"${ctx.steps[stepId].name}"`;
              }
            }
            return null;
          }).filter(Boolean);
          code += `            .set_valid_steps([${stepNames.join(', ')}]) \\\n`;
        }

        // Remove trailing backslash
        code = code.slice(0, -3) + '\n';
      });

      code += '\n';
    });
  }

  // Functions
  if (Object.keys(state.functions).length > 0) {
    code += `        # Add functions\n`;
    Object.values(state.functions).forEach(func => {
      code += `        self.add_swaig_function("${func.name}", "${func.purpose || 'Custom function'}")\n`;
    });
  }

  code += `

def main():
    agent = ${className}()
    agent.run()


if __name__ == "__main__":
    main()
`;

  return code;
}
